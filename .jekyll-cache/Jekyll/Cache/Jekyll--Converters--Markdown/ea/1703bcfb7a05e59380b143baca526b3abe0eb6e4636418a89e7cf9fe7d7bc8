I"î<p>This writeup is hosted at <a href="https://cal-cs184-student.github.io/sp22-project-webpages-sagnibak/project-1">https://cal-cs184-student.github.io/sp22-project-webpages-sagnibak/project-1</a>.</p>

<h2 id="part-1-rasterizing-single-color-triangles">Part 1: Rasterizing single-color triangles</h2>

<p>We first finding a bounding box by calculating the minimum and maximum
x and y coordinates. For each point, we determine whether itâ€™s inside
or outside the triangle by testing the orientation using the dot
product between the normal vector to the line and the vector
containing the point and a vertex of the line. If we traverse the
points in a clockwise manner, all signs should be negative. In
contrast, if we traverse the points in a counterclockwise manner, all
signs should be positive. To handle cases where the point lies on the
edge of the triangle, we denote landing on a line as <code class="language-plaintext highlighter-rouge">MAYBE</code>. Then we
enumerate all possibilities combinations of <code class="language-plaintext highlighter-rouge">TRUE/FALSE/MAYBE</code>s that
imply landing on or inside the triangle (either 2 MAYBEs which means
itâ€™s a corner, 1 <code class="language-plaintext highlighter-rouge">MAYBE</code> and two <code class="language-plaintext highlighter-rouge">FALSE</code>s, or 1 <code class="language-plaintext highlighter-rouge">MAYBE</code> and two
<code class="language-plaintext highlighter-rouge">TRUE</code>s). In the case the point is in the triangle, we update the
sample buffer with the color of the triangle.</p>

<p><img src="../proj1/task2_img/test4_16.png" alt="imag" /></p>
<h3 id="part-2-antialiasing-triangles">Part 2: Antialiasing triangles</h3>

<p>To properly antialias, we resized the sample buffer by <code class="language-plaintext highlighter-rouge">sqrt{sampling_rate}</code> in both height and width dimensions. To avoid any potential floating point issues, we opted to scale our triangle up and traverse through the triangle in whole increments. Then, to render the image at the original size, in <code class="language-plaintext highlighter-rouge">resolve_to_framebuffer</code>, we take <code class="language-plaintext highlighter-rouge">sampling rate</code> number of samples (corresponds to one pixel) and update the <code class="language-plaintext highlighter-rouge">rgb_framebuffer</code>.</p>
<h3 id="part-3-transforms">Part 3: Transforms</h3>

<h2 id="task-4-barycentric-coordinates">Task 4: Barycentric Coordinates</h2>

<p>Barycentric coordinates can be seen as a way to figure out the
distance from the three vertices of a triangle, providing a coordinate
system that is relative to the triangle. They allow us to
smoothly blend attributes at the vertices of a triangle. The attribute
of interest for us is color in this part, but it can also be used to
help translate between image and texture coordinates by blending the
texture coordinates at each of the vertices.</p>

<p><img src="../proj1/task4_img/color_triangle.png" alt="triangle_with_colors_at_vertices" /></p>

:ET